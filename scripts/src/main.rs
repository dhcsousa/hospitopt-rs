use anyhow::{anyhow, Context, Result};
use entity::{
    hospital,
    patient,
    prelude::{Hospital, HospitalSpeciality, Patient},
};
use sea_orm::{Database, DatabaseConnection, EntityTrait, QueryOrder};
use std::str::FromStr;

mod hospitals;
mod patients;

const TRIAGE_LEVELS: &[&str] = patients::TRIAGE_CONDITIONS;

#[tokio::main]
async fn main() -> Result<()> {
    dotenvy::dotenv().ok();

    let database_url =
        std::env::var("DATABASE_URL").context("DATABASE_URL environment variable is not set")?;

    let db = Database::connect(&database_url)
        .await
        .context("Failed to connect to the database")?;

    let patient_mode = resolve_patient_mode()?;

    let hospital_report = hospitals::seed(&db).await?;
    let patient_report = patients::seed(&db, patient_mode).await?;

    println!(
        "Seeded {hospitals} hospitals and {triage_levels} triage buckets",
        hospitals = hospital_report.hospitals,
        triage_levels = hospital_report.triage_levels,
    );
    println!(
        "Patient seeding mode: {mode}. Added {inserted} new patients (total now {total}).",
        mode = patient_mode,
        inserted = patient_report.inserted,
        total = patient_report.total,
    );

    print_hospital_snapshot(&db).await?;
    print_patient_snapshot(&db).await?;

    Ok(())
}

// BELLOW IS AUTOGENERATED
async fn print_hospital_snapshot(db: &DatabaseConnection) -> Result<()> {
    let rows = Hospital::find()
        .order_by_asc(hospital::Column::LocationName)
        .find_with_related(HospitalSpeciality)
        .all(db)
        .await
        .context("Failed to fetch hospital data")?;

    if rows.is_empty() {
        println!("\nNo hospitals found in the database.");
        return Ok(());
    }

    println!("\nCurrent hospital snapshot:");

    for (hospital, mut triages) in rows {
        println!(
            "- {name} (beds: {beds}, lat: {lat:.5}, lon: {lon:.5})",
            name = hospital.location_name,
            beds = hospital.bed_capacity,
            lat = hospital.latitude,
            lon = hospital.longitude,
        );

    triages.sort_by_key(|triage| triage_rank(&triage.triage_level, TRIAGE_LEVELS));

        for triage in triages {
            let minutes = triage.waiting_time_seconds / 60;
            let seconds = triage.waiting_time_seconds % 60;

            println!(
                "    â€¢ {level}: wait ~{minutes}m{seconds:02}s, beds {beds}",
                level = triage.triage_level,
                minutes = minutes,
                seconds = seconds,
                beds = triage.beds_capacity,
            );
        }
    }

    Ok(())
}

fn triage_rank(level: &str, ordering: &[&str]) -> usize {
    ordering
        .iter()
        .position(|name| *name == level)
        .unwrap_or(usize::MAX)
}

async fn print_patient_snapshot(db: &DatabaseConnection) -> Result<()> {
    let mut patients = Patient::find()
        .order_by_asc(patient::Column::Condition)
        .all(db)
        .await
        .context("Failed to fetch patient data")?;

    if patients.is_empty() {
        println!("\nNo patients found in the database.");
        return Ok(());
    }

    println!("\nCurrent patient snapshot:");

    patients.sort_by_key(|patient| triage_rank(&patient.condition, TRIAGE_LEVELS));

    for patient in patients {
        println!(
            "- {condition}: lat {lat:.5}, lon {lon:.5}",
            condition = patient.condition,
            lat = patient.latitude,
            lon = patient.longitude,
        );
    }

    Ok(())
}

fn resolve_patient_mode() -> Result<patients::PatientSeedMode> {
    match std::env::var("PATIENT_SEED_MODE") {
        Ok(value) => patients::PatientSeedMode::from_str(&value)
            .map_err(|err| anyhow!("Invalid PATIENT_SEED_MODE value: {err}")),
        Err(std::env::VarError::NotPresent) => Ok(patients::PatientSeedMode::Reset),
        Err(e) => Err(anyhow!(e)),
    }
}
