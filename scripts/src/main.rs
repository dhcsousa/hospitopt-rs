use anyhow::{Context, Result};
use entity::{
    hospital,
    prelude::{Hospital, HospitalSpeciality},
};
use sea_orm::{Database, DatabaseConnection, EntityTrait, QueryOrder};

mod hospitals;
// mod patients; // TODO: implement patient seeding

#[tokio::main]
async fn main() -> Result<()> {
    dotenvy::dotenv().ok();

    let database_url =
        std::env::var("DATABASE_URL").context("DATABASE_URL environment variable is not set")?;

    let db = Database::connect(&database_url)
        .await
        .context("Failed to connect to the database")?;

    let hospital_report = hospitals::seed(&db).await?;

    println!(
        "Seeded {hospitals} hospitals and {triage_levels} triage buckets",
        hospitals = hospital_report.hospitals,
        triage_levels = hospital_report.triage_levels,
    );

    print_hospital_snapshot(&db).await?;

    Ok(())
}

// BELLOW IS AUTOGENERATED
async fn print_hospital_snapshot(db: &DatabaseConnection) -> Result<()> {
    const TRIAGE_ORDER: &[(&str, usize)] = &[
        ("Emergência (Vermelho)", 0),
        ("Muito Urgente (Laranja)", 1),
        ("Urgente (Amarelo)", 2),
        ("Pouco Urgente (Verde)", 3),
        ("Não Urgente (Azul)", 4),
    ];

    let rows = Hospital::find()
        .order_by_asc(hospital::Column::LocationName)
        .find_with_related(HospitalSpeciality)
        .all(db)
        .await
        .context("Failed to fetch hospital data")?;

    if rows.is_empty() {
        println!("\nNo hospitals found in the database.");
        return Ok(());
    }

    println!("\nCurrent hospital snapshot:");

    for (hospital, mut triages) in rows {
        println!(
            "- {name} (beds: {beds}, lat: {lat:.5}, lon: {lon:.5})",
            name = hospital.location_name,
            beds = hospital.bed_capacity,
            lat = hospital.latitude,
            lon = hospital.longitude,
        );

        triages.sort_by_key(|triage| triage_rank(&triage.triage_level, TRIAGE_ORDER));

        for triage in triages {
            let minutes = triage.waiting_time_seconds / 60;
            let seconds = triage.waiting_time_seconds % 60;

            println!(
                "    • {level}: wait ~{minutes}m{seconds:02}s, beds {beds}",
                level = triage.triage_level,
                minutes = minutes,
                seconds = seconds,
                beds = triage.beds_capacity,
            );
        }
    }

    Ok(())
}

fn triage_rank(level: &str, ordering: &[(&str, usize)]) -> usize {
    ordering
        .iter()
        .find(|(name, _)| *name == level)
        .map(|(_, rank)| *rank)
        .unwrap_or(usize::MAX)
}
